<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.7" xml:lang="en-US">
  <compounddef id="md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker" kind="page">
    <compoundname>md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker</compoundname>
    <title>How to add a 3rd party packages into the workflow and Docker</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><orderedlist>
<listitem><para>How to add packages into the workflow</para>
</listitem></orderedlist>
</para>
<para>How to add packages into Docker image</para>
<sect1 id="md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker_1autotoc_md28">
<title>Workflow and GitHub Actions.</title>
<para>A workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration. <bold>If you might need it!</bold></para>
<sect2 id="md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker_1autotoc_md29">
<title>About YAML syntax for workflows</title>
<para>Workflow files use YAML syntax, and must have either a .yml or .yaml file extension. If you&apos;re new to YAML and want to learn more, see <ulink url="https://www.codeproject.com/Articles/1214409/Learn-YAML-in-five-minutes">"Learn YAML in five minutes."</ulink></para>
<para>In our repository we store workflow files in the .github/workflows directory. (build.yml) <hruler/>
</para>
<para>Here is an example of how to write such a file and how to include the packages we need:</para>
<para><itemizedlist>
<listitem><para>The name of your workflow. GitHub displays the names of your workflows on your repository&apos;s actions page. If you omit name, GitHub sets it to the workflow file path relative to the root of the repository.</para>
</listitem></itemizedlist>
</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">name:<sp/>Clang-Build</highlight></codeline>
</programlisting><itemizedlist>
<listitem><para>Required. The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see <ulink url="https://docs.github.com/en/articles/events-that-trigger-workflows">"Events that trigger workflows."</ulink></para>
</listitem></itemizedlist>
</para>
<para>Example using a single event: <programlisting filename=".yaml"><codeline><highlight class="normal">#<sp/>Triggered<sp/>when<sp/>code<sp/>is<sp/>pushed<sp/>to<sp/>any<sp/>branch<sp/>in<sp/>a<sp/>repository</highlight></codeline>
<codeline><highlight class="normal">on:<sp/>push</highlight></codeline>
</programlisting> Example using a list of events <programlisting filename=".yaml"><codeline><highlight class="normal">#<sp/>Triggers<sp/>the<sp/>workflow<sp/>on<sp/>push<sp/>or<sp/>pull<sp/>request<sp/>events</highlight></codeline>
<codeline><highlight class="normal">on:<sp/>[push,<sp/>pull_request]</highlight></codeline>
</programlisting> Another example <programlisting filename=".yaml"><codeline><highlight class="normal">#<sp/>Controls<sp/>when<sp/>the<sp/>action<sp/>will<sp/>run.<sp/>Triggers<sp/>the<sp/>workflow<sp/>on<sp/>push<sp/>or<sp/>pull<sp/>request</highlight></codeline>
<codeline><highlight class="normal">#<sp/>events<sp/>but<sp/>only<sp/>for<sp/>the<sp/>master<sp/>branch</highlight></codeline>
<codeline><highlight class="normal">on:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>push:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>branches:<sp/>[<sp/>master,dev/develop,dev/coroutine,dev/clang_build]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pull_request:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>branches:<sp/>[<sp/>master,dev/develop,dev/coroutine]</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.&lt;job_id&gt;.needs keyword.</para>
</listitem></itemizedlist>
</para>
<para>Each job runs in a runner environment specified by runs-on.</para>
<para>You can run an unlimited number of jobs as long as you are within the workflow usage limits.</para>
<para>Each job must have an id to associate with the job. The key job_id is a string and its value is a map of the job&apos;s configuration data. You must replace &lt;job_id&gt; with a string that is unique to the jobs object. The &lt;job_id&gt; must start with a letter or _ and contain only alphanumeric characters, -, or _.</para>
<para>Example <programlisting filename=".yaml"><codeline><highlight class="normal">jobs:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_first_job:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>name:<sp/>My<sp/>first<sp/>job</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_second_job:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>name:<sp/>My<sp/>second<sp/>job</highlight></codeline>
<codeline><highlight class="normal">jobs.&lt;job_id&gt;.name</highlight></codeline>
</programlisting> The name of the job displayed on GitHub.</para>
<para>jobs.&lt;job_id&gt;.needs Identifies any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue.</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">Example<sp/>requiring<sp/>dependent<sp/>jobs<sp/>to<sp/>be<sp/>successful</highlight></codeline>
<codeline><highlight class="normal">jobs:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>job1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>job2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>needs:<sp/>job1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>job3:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>needs:<sp/>[job1,<sp/>job2]</highlight></codeline>
</programlisting></para>
<para>In this example, job1 must complete successfully before job2 begins, and job3 waits for both job1 and job2 to complete. The jobs in this example run sequentially: job1, job2, job3.</para>
<para><itemizedlist>
<listitem><para>GitHub-hosted runners If you use a GitHub-hosted runner, each job runs in a fresh instance of a virtual environment specified by runs-on.</para>
</listitem></itemizedlist>
</para>
<para>Available GitHub-hosted runner types are: \ Windows <ref refid="class_server" kindref="compound">Server</ref> 2019 \ Ubuntu 20.04 \ Ubuntu 18.04 \ Ubuntu 16.04 \ macOS Big Sur 11.0 \ macOS Catalina 10.15</para>
<para>Example <programlisting filename=".yaml"><codeline><highlight class="normal">runs-on:<sp/>ubuntu-latest</highlight></codeline>
</programlisting></para>
<para><bold>Self-hosted runners</bold> To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.</para>
<para>All self-hosted runners have the self-hosted label, and you can select any self-hosted runner by providing only the self-hosted label. Alternatively, you can use self-hosted in an array with additional labels, such as labels for a specific operating system or system architecture, to select only the runner types you specify.</para>
<para>Example <programlisting filename=".yaml"><codeline><highlight class="normal">runs-on:<sp/>[self-hosted,<sp/>linux]</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>Workflow dispatch Allows you to run this workflow manually from the Actions tab. Example <programlisting filename=".yaml"><codeline><highlight class="normal">workflow_dispatch:</highlight></codeline>
</programlisting> Result - we can click to button &apos;Run workflow&apos;</para>
</listitem></itemizedlist>
</para>
<para><image type="html" name="https://i2.wp.com/user-images.githubusercontent.com/1865328/86147571-2de93700-babf-11ea-8a08-e4beffd3abe9.png?ssl=1" inline="yes"></image>
</para>
<para><itemizedlist>
<listitem><para>Steps represent a sequence of tasks that will be executed as part of the job.</para>
</listitem></itemizedlist>
<orderedlist>
<listitem><para>All config is written in yaml, so it is important to follow the syntax and indentation, a new entity in the list starts with &quot;-&quot;</para>
</listitem><listitem><para>The steps are essentially an ordered list. They will be executed one by one strictly in sequence</para>
</listitem></orderedlist>
</para>
<para>Example <programlisting filename=".yaml"><codeline><highlight class="normal">steps:</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>Name. Name is just for display in the interface, you can do without it just fine.</para>
</listitem></itemizedlist>
</para>
<para>Example <programlisting filename=".yaml"><codeline><highlight class="normal">name:<sp/>build</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>Uses. Specify an action to run as part of a step in your job. You can use an action defined in the same repository as the workflow, a public repository elsewhere on GitHub, or in a published Docker container image. Here we specify the name of some already written action, if we want to use it. The action can be a specific branch in a specific repository (any repository), it can be code stored in a neighboring folder, or it can be a docker-image (<ulink url="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsuses">full list</ulink>) This example uses <computeroutput>actions/checkout@v2</computeroutput>. You can easily find them <ulink url="https://github.com/marketplace/actions/checkout">by name</ulink> in the marketplace and look at the source code of a specific version (it comes after the @ in the name) to see what they do. checkout does a pull of the repository and the branch in which it is running.</para>
</listitem></itemizedlist>
</para>
<para>tag is strongly recommended:</para>
<para>checks-out your repository under $GITHUB_WORKSPACE, so your job can access it <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>actions/checkout@v2</highlight></codeline>
</programlisting> for actions in a public repository <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>{owner}/{repo}@{ref}<sp/></highlight></codeline>
</programlisting> for actions in a subdirectory of a public repository <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>{owner}/{repo}/{path}@{ref}<sp/></highlight></codeline>
</programlisting> for actions in a a subdirectory of the same repository <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>./path/to/dir<sp/></highlight></codeline>
</programlisting> for actions on Docker Hub <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>docker://{image}:{tag}<sp/></highlight></codeline>
</programlisting> for actions in a public registry <programlisting filename=".yaml"><codeline><highlight class="normal">uses:<sp/>docker://{host}/{image}:{tag}<sp/></highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>Run. Runs some command in the shell. You can&apos;t use a shell command together with an action, they must live in different steps</para>
</listitem></itemizedlist>
</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sudo<sp/>docker<sp/>build<sp/>.<sp/>-t<sp/>juniorgram:1.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>docker<sp/>run<sp/>--rm<sp/>--name<sp/>juniorgram-container<sp/>juniorgram:1.0</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker_1autotoc_md30">
<title>How to add packages into the workflow</title>
<para><itemizedlist>
<listitem><para>Let&apos;s move on to the most important thing, how do we use the packages that we need. It really depends on the environment in which you are running virtual machine on Github or locally.</para>
</listitem></itemizedlist>
</para>
<para>If you want to use the packages needed to implement a new feature, it is recommended to first find out <bold>if they are included in the standard build of the machine</bold> on which you want to test your feature. Take, for example, ubuntu.We need cmake for the build but we have it in the standard build, then we know that ubuntu has the apt package manager and we can use it to install our cmake.</para>
<para>Example</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">-<sp/>name:<sp/>Setup<sp/>CMake</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>sudo<sp/>apt-get<sp/>-y<sp/>install<sp/>cmake</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>cmake<sp/>--version<sp/></highlight></codeline>
</programlisting> We also do sudo <computeroutput>sudo apt update</computeroutput> to get the latest version of the packages we need. The following example shows how we can use a package that is originally in the ubuntu distribution:</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">-<sp/>name:<sp/>Build<sp/>Docker<sp/>image.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sudo<sp/>docker<sp/>build<sp/>.<sp/>-t<sp/>juniorgram:1.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>docker<sp/>run<sp/>--rm<sp/>--name<sp/>juniorgram-container<sp/>juniorgram:1.0</highlight></codeline>
</programlisting></para>
<para>The following examples show you how to install certain packages:</para>
<para><programlisting filename=".yaml"><codeline><highlight class="normal">-<sp/>name:<sp/>Setup<sp/>CLang<sp/>compiler</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sudo<sp/>apt-get<sp/>update</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sudo<sp/>apt-get<sp/>-y<sp/>update</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sudo<sp/>bash<sp/>-c<sp/>&quot;$(wget<sp/>-O<sp/>-<sp/>https://apt.llvm.org/llvm.sh)&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-<sp/>name:<sp/>Setup<sp/>CMake</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sudo<sp/>apt-get<sp/>-y<sp/>install<sp/>cmake</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cmake<sp/>--version</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-<sp/>name:<sp/>Setup<sp/>python</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>uses:<sp/>actions/setup-python@v2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>with:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>python-version:<sp/>&apos;3.8&apos;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-<sp/>name:<sp/>Install<sp/>pip<sp/>dependencies</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>uses:<sp/><sp/>BSFishy/pip-action@v1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>with:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>packages:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conan</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mako</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-<sp/>name:<sp/>Setup<sp/>conan<sp/>dependencies</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conan<sp/>remote<sp/>add<sp/>bincrafters<sp/>https://api.bintray.com/conan/bincrafters/public-conan</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-<sp/>name:<sp/>Download<sp/>libraries<sp/>from<sp/>Conan</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>run:<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>export<sp/>CC=/usr/bin/clang</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>export<sp/>CXX=/usr/bin/clang++</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mkdir<sp/>${{<sp/>github.workspace<sp/>}}/Firmware/build<sp/>&amp;&amp;<sp/>cd<sp/>${{<sp/>github.workspace<sp/>}}/Firmware/build</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conan<sp/>install<sp/>${{<sp/>github.workspace<sp/>}}/Firmware/conanfile.txt<sp/>--install-folder<sp/>${{<sp/>runner.workspace<sp/>}}/Firmware/build/<sp/><sp/>-s<sp/>compiler=clang<sp/>-s<sp/>compiler.version=10<sp/>--build=missing</highlight></codeline>
</programlisting> </para>
</sect2>
</sect1>
<sect1 id="md__docs_2_legacy_2_how_01to_01add_01a_013rd_01party_01packages_01into_01the_01workflow_01and_01_docker_1autotoc_md31">
<title>How to add packages into Docker image</title>
<para>Below is an example of our docker file and how it looks like to install the necessary packages. You can use this file to make your own docker file with the packages you need.</para>
<para>Our Dockerfile: <programlisting filename=".dockerfile"><codeline><highlight class="normal">FROM<sp/>alpine:latest<sp/>-<sp/>specifies<sp/>the<sp/>base<sp/>(parent)<sp/>image.</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">COPY<sp/>.<sp/>/usr/src/build<sp/>-<sp/>copies<sp/>the<sp/>contents<sp/>of<sp/>the<sp/>current<sp/>directory<sp/>to<sp/>/usr/src/build.</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">WORKDIR<sp/>/usr/src/build<sp/>-<sp/>sets<sp/>current<sp/>directory<sp/>as<sp/>working<sp/>directory.<sp/>All<sp/>commands<sp/>will<sp/>be<sp/>built<sp/>from<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal"><sp/>directory.</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">RUN<sp/>apk<sp/>update<sp/>&amp;&amp;<sp/>apk<sp/>upgrade<sp/>&amp;&amp;<sp/>apk<sp/>add<sp/>--no-cache<sp/>cmake<sp/>make<sp/>gcc<sp/>g++<sp/>bash<sp/>git<sp/>python3<sp/>linux-headers<sp/>-<sp/>his<sp/>line<sp/>specifies<sp/>the<sp/>packages<sp/>you<sp/>need<sp/>to<sp/>run.<sp/>They<sp/>are<sp/>listed<sp/>with<sp/>a<sp/>space<sp/>after<sp/>the<sp/>--no-cache<sp/>flag.<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">RUN<sp/>wget<sp/>-qO-<sp/>https:</highlight><highlight class="comment">//bootstrap.pypa.io/get-pip.py<sp/>|<sp/>python3<sp/>\</highlight></codeline>
<codeline><highlight class="comment">&amp;&amp;<sp/>pip3<sp/>install<sp/>conan<sp/>-<sp/>in<sp/>this<sp/>line<sp/>we<sp/>use<sp/>wget<sp/>to<sp/>download<sp/>the<sp/>file<sp/>and<sp/>give<sp/>the<sp/>output<sp/>from<sp/>the<sp/>downloaded<sp/>file<sp/>to<sp/>the<sp/>python3<sp/>interpreter,<sp/>pip3<sp/>is<sp/>installed<sp/>and<sp/>conan<sp/>is<sp/>installed<sp/>to<sp/>install<sp/>the<sp/>libraries.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">RUN<sp/>cmake<sp/>-DCMAKE_BUILD_TYPE=Release<sp/>.<sp/>\</highlight></codeline>
<codeline><highlight class="normal">&amp;&amp;<sp/>cmake<sp/>--build<sp/>.<sp/>-<sp/>run<sp/>build<sp/>project</highlight></codeline>
</programlisting> Again, since we are using the alpine distribution, before installing the necessary packages, it is worth looking to see if they are in the apk package manager(<ulink url="https://pkgs.alpinelinux.org/packages">packages list</ulink>). If they are there, you can install them as shown in the example. If not, then it makes sense to see if these packages are in pip. If not, then there is an option to build from source files :) </para>
</sect1>
    </detaileddescription>
    <location file="Docs/Legacy/How to add a 3rd party packages into the workflow and Docker.md"/>
  </compounddef>
</doxygen>

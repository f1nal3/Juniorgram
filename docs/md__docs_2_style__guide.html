<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Juniorgram: Style_guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="juniorgram_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Juniorgram<span id="projectnumber">&#160;0.6</span>
   </div>
   <div id="projectbrief">C++ written messenger! Never before and never again!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Style_guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li># Как писать код на C++ {#styleguide}</li>
</ol>
<h2><a class="anchor" id="autotoc_md43"></a>
Общее</h2>
<p><b>1.</b> Этот текст носит рекомендательный характер.</p>
<p><b>2.</b> Стиль нужен для единообразия. Единообразие нужно, чтобы было проще (удобнее) читать код. А также, чтобы было легче осуществлять поиск по коду.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Форматирование</h2>
<p><b>1.</b> Большую часть форматирования сделает автоматически <code>clang-format</code>.</p>
<p><b>2.</b> Отступы — 4 пробела. Настройте среду разработки так, чтобы при нажатии на Tab, происходило добавление четырёх пробелов.</p>
<p><b>3.</b> Открывающая и закрывающие фигурные скобки на отдельной строке.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">inline void readBoolText(bool&amp; x, ReadBuffer&amp; buf)</div>
<div class="line">{</div>
<div class="line">    char tmp = &#39;0&#39;;</div>
<div class="line">    readChar(tmp, buf);</div>
<div class="line">    x = tmp != &#39;0&#39;;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>4.</b> Если всё тело функции — один <code>statement</code>, то его можно разместить на одной строке. При этом, вокруг фигурных скобок ставятся пробелы (кроме пробела на конце строки).</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">inline size_t mask() const                { return buf_size() - 1; }</div>
<div class="line">inline size_t place(HashValue x) const    { return x &amp; mask(); }</div>
</div><!-- fragment --><p><b>5.</b> Для функций. Пробелы вокруг скобок не ставятся.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">void reinsert(const Value&amp; x)</div>
</div><!-- fragment --><div class="fragment"><div class="line"> cpp</div>
<div class="line">memcpy(&amp;buf[place_value], &amp;x, sizeof(x));</div>
</div><!-- fragment --><p><b>6.</b> В выражениях <code>if</code>, <code>for</code>, <code>while</code> и т.д. перед открывающей скобкой ставится пробел (в отличие от вызовов функций).</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">for (size_t i = 0; i &lt; rows; i += storage.index_granularity)</div>
</div><!-- fragment --><p><b>7.</b> Вокруг бинарных операторов (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, …), а также тернарного оператора <code>?:</code> ставятся пробелы.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">UInt16 year = (s[0] - &#39;0&#39;) * 1000 + (s[1] - &#39;0&#39;) * 100 + (s[2] - &#39;0&#39;) * 10 + (s[3] - &#39;0&#39;);</div>
<div class="line">UInt8 month = (s[5] - &#39;0&#39;) * 10 + (s[6] - &#39;0&#39;);</div>
<div class="line">UInt8 day = (s[8] - &#39;0&#39;) * 10 + (s[9] - &#39;0&#39;);</div>
</div><!-- fragment --><p><b>8.</b> Если ставится перенос строки, то оператор пишется на новой строке, и перед ним увеличивается отступ.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">if (elapsed_ns)</div>
<div class="line">    message &lt;&lt; &quot; (&quot;</div>
<div class="line">        &lt;&lt; rows_read_on_server * 1000000000 / elapsed_ns &lt;&lt; &quot; rows/s., &quot;</div>
<div class="line">        &lt;&lt; bytes_read_on_server * 1000.0 / elapsed_ns &lt;&lt; &quot; MB/s.) &quot;;</div>
</div><!-- fragment --><p><b>9.</b> Внутри строки можно, выполнять выравнивание с помощью пробелов.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">dst.ClickLogID         = click.LogID;</div>
<div class="line">dst.ClickEventID       = click.EventID;</div>
<div class="line">dst.ClickGoodEvent     = click.GoodEvent;</div>
</div><!-- fragment --><p><b>10.</b> Вокруг операторов <code>.</code>, <code>-&gt;</code> не ставятся пробелы.</p>
<p>При необходимости, оператор может быть перенесён на новую строку. В этом случае, перед ним увеличивается отступ.</p>
<p><b>11.</b> Унарные операторы <code>--</code>, <code>++</code>, <code>*</code>, <code>&amp;</code>, … не отделяются от аргумента пробелом.</p>
<p><b>12.</b> После запятой ставится пробел, а перед — нет. Аналогично для точки с запятой внутри выражения <code>for</code>.</p>
<p><b>13.</b> Оператор <code>[]</code> не отделяется пробелами.</p>
<p><b>14.</b> В выражении <code>template &lt;...&gt;</code>, между <code>template</code> и <code>&lt;</code> ставится пробел, а после <code>&lt;</code> и до <code>&gt;</code> не ставится.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">template &lt;typename TKey, typename TValue&gt;</div>
<div class="line">struct AggregatedStatElement</div>
<div class="line">{}</div>
</div><!-- fragment --><p><b>15.</b> В классах и структурах, <code>public</code>, <code>private</code>, <code>protected</code> пишется на том же уровне, что и <code>class/struct</code>, а остальной код с отступом.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class MultiVersion</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    /// Version of object for usage. shared_ptr manage lifetime of version.</div>
<div class="line">    using Version = std::shared_ptr&lt;const T&gt;;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>16.</b> Если на весь файл один <code>namespace</code> и кроме него ничего существенного нет, то отступ внутри <code>namespace</code> не нужен.</p>
<p><b>17.</b> Если блок для выражения <code>if</code>, <code>for</code>, <code>while</code>, … состоит из одного <code>statement</code>, то фигурные скобки не обязательны.</p>
<p>Если внутренний <code>statement</code> содержит фигурные скобки или <code>else</code>, то внешний блок следует писать в фигурных скобках.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/// Finish write.</div>
<div class="line">for (auto&amp; stream : streams)</div>
<div class="line">    stream.second-&gt;finalize();</div>
</div><!-- fragment --><p><b>18.</b> Не должно быть пробелов на концах строк.</p>
<p><b>19.</b> Исходники в кодировке UTF-8.</p>
<p><b>20.</b> В строковых литералах можно использовать не-ASCII.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">&lt;&lt; &quot;, &quot; &lt;&lt; (timer.elapsed() / chunks_stats.hits) &lt;&lt; &quot; μsec/hit.&quot;;</div>
</div><!-- fragment --><p><b>21.</b> Не пишите несколько выражений в одной строке.</p>
<p><b>22.</b> Внутри функций группируйте блоки кода, отделяя их не более, чем одной пустой строкой.</p>
<p><b>23.</b> Функции, классы, и т. п. отделяются друг от друга одной или двумя пустыми строками.</p>
<p><b>24.</b> <code>const</code> (относящийся к значению) пишется до имени типа.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//correct</div>
<div class="line">const char* pos</div>
<div class="line">const std::string&amp; s</div>
<div class="line">//incorrect</div>
<div class="line">char const* pos</div>
</div><!-- fragment --><p><b>25.</b> При объявлении указателя или ссылки, символы <code>*</code> и <code>&amp;</code> не отделяются пробелами с обеих сторон.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//correct</div>
<div class="line">const char* pos</div>
<div class="line">//incorrect</div>
<div class="line">const char * pos</div>
<div class="line">const char *pos</div>
</div><!-- fragment --><p><b>26.</b> При использовании шаблонных типов, пишите <code>using</code> (кроме, возможно, простейших случаев).</p>
<p>То есть, параметры шаблона указываются только в <code>using</code> и затем не повторяются в коде.</p>
<p><code>using</code> может быть объявлен локально, например, внутри функции.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//correct</div>
<div class="line">using FileStreams = std::map&lt;std::string, std::shared_ptr&lt;Stream&gt;&gt;;</div>
<div class="line">FileStreams streams;</div>
<div class="line">//incorrect</div>
<div class="line">std::map&lt;std::string, std::shared_ptr&lt;Stream&gt;&gt; streams;</div>
</div><!-- fragment --><p><b>27.</b> Нельзя объявлять несколько переменных разных типов в одном выражении.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//incorrect</div>
<div class="line">int x, *y;</div>
</div><!-- fragment --><p><b>28.</b> C-style cast не используется.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//incorrect</div>
<div class="line">std::cerr &lt;&lt; (int)c &lt;&lt;; std::endl;</div>
<div class="line">//correct</div>
<div class="line">std::cerr &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p><b>29.</b> В классах и структурах, группируйте отдельно методы и отдельно члены, внутри каждой области видимости.</p>
<p><b>30.</b> Для не очень большого класса/структуры, можно не отделять объявления методов от реализации.</p>
<p>Аналогично для маленьких методов в любых классах/структурах.</p>
<p>Для шаблонных классов/структур, лучше не отделять объявления методов от реализации (так как иначе они всё равно должны быть определены в той же единице трансляции).</p>
<p><b>31.</b> Не обязательно умещать код по ширине в 80 символов. Можно в 140.</p>
<p><b>32.</b> Всегда используйте префиксный инкремент/декремент, если постфиксный не нужен.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
Комментарии</h2>
<p><b>1.</b> Необходимо обязательно писать комментарии во всех нетривиальных местах.</p>
<p>Это очень важно. При написании комментария, можно успеть понять, что код не нужен вообще, или что всё сделано неверно.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/** Part of piece of memory, that can be used.</div>
<div class="line">  * For example, if internal_buffer is 1MB, and there was only 10 bytes loaded to buffer from file for reading,</div>
<div class="line">    * then working_buffer will have size of only 10 bytes</div>
<div class="line">  * (working_buffer.end() will point to position right after those 10 bytes available for read).</div>
<div class="line">  */</div>
</div><!-- fragment --><p><b>2.</b> Комментарии могут быть сколь угодно подробными.</p>
<p><b>3.</b> Комментарии пишутся до соответствующего кода. В редких случаях после, на той же строке.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/** Parses and executes the query.</div>
<div class="line">*/</div>
<div class="line">void executeQuery(</div>
<div class="line">    ReadBuffer&amp; istr, /// Where to read the query from (and data for INSERT, if applicable)</div>
<div class="line">    WriteBuffer&amp; ostr, /// Where to write the result</div>
<div class="line">    Context&amp; context, /// DB, tables, data types, engines, functions, aggregate functions...</div>
<div class="line">    BlockInputStreamPtr&amp; query_plan, /// Here could be written the description on how query was executed</div>
<div class="line">    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// Up to which stage process the SELECT query</div>
<div class="line">    )</div>
</div><!-- fragment --><p><b>4.</b> Комментарии следует писать только на английском языке.</p>
<p><b>5.</b> При написании библиотеки, разместите подробный комментарий о том, что это такое, в самом главном заголовочном файле.</p>
<p><b>6.</b> Нельзя писать комментарии, которые не дают дополнительной информации. В частности, нельзя писать пустые комментарии вроде этого:</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/*</div>
<div class="line">* Procedure Name:</div>
<div class="line">* Original procedure name:</div>
<div class="line">* Author:</div>
<div class="line">* Date of creation:</div>
<div class="line">* Dates of modification:</div>
<div class="line">* Modification authors:</div>
<div class="line">* Original file name:</div>
<div class="line">* Purpose:</div>
<div class="line">* Intent:</div>
<div class="line">* Designation:</div>
<div class="line">* Classes used:</div>
<div class="line">* Constants:</div>
<div class="line">* Local variables:</div>
<div class="line">* Parameters:</div>
<div class="line">* Date of creation:</div>
<div class="line">* Purpose:</div>
<div class="line">*/</div>
</div><!-- fragment --><p><b>7.</b> Нельзя писать мусорные комментарии (автор, дата создания…) в начале каждого файла.</p>
<p><b>8.</b> Однострочные комментарии начинаются с трёх слешей: <code>///</code> , многострочные с <code>/**</code>. Такие комментарии считаются «документирующими».</p>
<p>Замечание: такие комментарии могут использоваться для генерации документации с помощью Doxygen.</p>
<p><b>9.</b> В начале и конце многострочного комментария, не должно быть пустых строк (кроме строки, на которой закрывается многострочный комментарий).</p>
<p><b>10.</b> Для закомментированных кусков кода, используются обычные, не «документирующие» комментарии.</p>
<p><b>11.</b> Удаляйте закомментированные куски кода перед коммитом.</p>
<p><b>12.</b> Не нужно писать нецензурную брань в комментариях или коде ;)</p>
<p><b>13.</b> Не пишите прописными буквами. Не используйте излишнее количество знаков препинания.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/// WHAT THE FAIL???</div>
</div><!-- fragment --><p><b>14.</b> Не составляйте из комментариев строки-разделители.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">///******************************************************</div>
</div><!-- fragment --><p><b>15.</b> Не нужно писать в комментарии диалог (лучше сказать устно).</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/// Why did you do this stuff?</div>
</div><!-- fragment --><p><b>16.</b> Не нужно писать комментарий в конце блока о том, что представлял собой этот блок.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/// for</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
Имена</h2>
<p><b>1.</b> В именах локальных переменных используйте camelCase.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">size_t maxBlockSize;</div>
</div><!-- fragment --><p> <b>2.</b> В именах членов класса используйте underscore.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">private:</div>
<div class="line">size_t _maxBlockSize;</div>
</div><!-- fragment --><p><b>3.</b> Имена функций (методов) camelCase с маленькой буквы.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">std::string getName() const override { return &quot;Memory&quot;; }</div>
</div><!-- fragment --><p><b>4.</b> Имена классов (структур) - CamelCase с большой буквы. Префиксы кроме I для интерфейсов - не используются.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">class StorageMemory : public IStorage</div>
</div><!-- fragment --><p><b>5.</b> <code>using</code> называются также, как классы, либо с <code>_t</code> на конце.</p>
<p><b>6.</b> Имена типов — параметров шаблонов: в простых случаях - <code>T</code>; <code>T</code>, <code>U</code>; <code>T1</code>, <code>T2</code>.</p>
<p>В более сложных случаях - либо также, как имена классов, либо можно добавить в начало букву <code>T</code>.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">template &lt;typename TKey, typename TValue&gt;</div>
<div class="line">struct AggregatedStatElement</div>
</div><!-- fragment --><p><b>7.</b> Имена констант — параметров шаблонов: либо также, как имена переменных, либо <code>N</code> в простом случае.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">template &lt;bool without_www&gt;</div>
<div class="line">struct ExtractDomain</div>
</div><!-- fragment --><p><b>8.</b> Для абстрактных классов (интерфейсов) можно добавить в начало имени букву <code>I</code>.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">class IBlockInputStream</div>
</div><!-- fragment --><p><b>9.</b> Если переменная используется достаточно локально, то можно использовать короткое имя.</p>
<p>В остальных случаях используйте имя, описывающее смысл.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">bool info_successfully_loaded = false;</div>
</div><!-- fragment --><p><b>10.</b> В именах <code>define</code> и глобальных констант используется ALL_CAPS с подчёркиванием.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">#define MAX_SRC_TABLE_NAMES_TO_STORE 1000</div>
</div><!-- fragment --><p><b>11.</b> Имена файлов с кодом называйте по стилю соответственно тому, что в них находится.</p>
<p>Если в файле находится один класс, назовите файл, как класс (CamelCase).</p>
<p>Если в файле находится одна функция, назовите файл, как функцию (CamelCase).</p>
<p><b>12.</b> Если имя содержит сокращение, то:</p>
<ul>
<li>для имён переменных, всё сокращение пишется маленькими буквами <code>mysql_connection</code> (не <code>mySQL_connection</code>).</li>
<li>для имён классов и функций, сохраняются большие буквы в сокращении <code>MySQLConnection</code> (не <code>MySqlConnection</code>).</li>
</ul>
<p><b>13.</b> Параметры конструктора, использующиеся сразу же для инициализации соответствующих членов класса, следует назвать также, как и члены класса, добавив подчёркивание в конец.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">FileQueueProcessor(</div>
<div class="line">    const std::string&amp; path_,</div>
<div class="line">    const std::string&amp; prefix_,</div>
<div class="line">    std::shared_ptr&lt;FileHandler&gt; handler_)</div>
<div class="line">    : path(path_),</div>
<div class="line">    prefix(prefix_),</div>
<div class="line">    handler(handler_),</div>
<div class="line">    log(&amp;Logger::get(&quot;FileQueueProcessor&quot;))</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>Также можно называть параметры конструктора так же, как и члены класса (не добавлять подчёркивание), но только если этот параметр не используется в теле конструктора.</p>
<p><b>14.</b> Именование локальных переменных и членов класса никак не отличается (никакие префиксы не нужны).</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">timer (not timer_)</div>
</div><!-- fragment --><p><b>15.</b> Константы в <code>enum</code> — CamelCase с большой буквы. Также допустим ALL_CAPS. Если <code>enum</code> не локален, то используйте <code>enum class</code>.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">enum class CompressionMethod</div>
<div class="line">{</div>
<div class="line">    QuickLZ = 0,</div>
<div class="line">    LZ4     = 1,</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>16.</b> Все имена - по-английски. Транслит с русского использовать нельзя.</p>
<div class="fragment"><div class="line"> text</div>
<div class="line">не Stroka</div>
</div><!-- fragment --><p><b>17.</b> Сокращения (из нескольких букв разных слов) в именах можно использовать только если они являются общепринятыми (если для сокращения можно найти расшифровку в английской википедии или сделав поисковый запрос).</p>
<div class="fragment"><div class="line"> text</div>
<div class="line">`AST`, `SQL`.</div>
<div class="line"> </div>
<div class="line">Не `NVDH` (что-то неведомое)</div>
</div><!-- fragment --><p>Сокращения в виде обрезанного слова можно использовать, только если такое сокращение является широко используемым.</p>
<p>Впрочем, сокращения также можно использовать, если расшифровка находится рядом в комментарии.</p>
<p><b>18.</b> Имена файлов с исходниками на C++ должны иметь расширение только <code>.cpp</code>. Заголовочные файлы - только <code>.hpp</code>.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Как писать код</h2>
<p><b>1.</b> Управление памятью.</p>
<p>Ручное освобождение памяти (<code>delete</code>) можно использовать только в библиотечном коде.</p>
<p>В свою очередь, в библиотечном коде, оператор <code>delete</code> можно использовать только в деструкторах.</p>
<p>В прикладном коде следует делать так, что память освобождается каким-либо объектом, который владеет ей.</p>
<p>Примеры:</p>
<ul>
<li>проще всего разместить объект на стеке, или сделать его членом другого класса.</li>
<li>для большого количества маленьких объектов используйте контейнеры.</li>
<li>для автоматического освобождения маленького количества объектов, выделенных на куче, используйте <code>shared_ptr/unique_ptr</code>.</li>
</ul>
<p><b>2.</b> Управление ресурсами.</p>
<p>Используйте <code>RAII</code> и см. пункт выше.</p>
<p><b>3.</b> Обработка ошибок.</p>
<p>Используйте исключения. В большинстве случаев, нужно только кидать исключения, а ловить - не нужно (потому что <code>RAII</code>).</p>
<p>В программах офлайн обработки данных, зачастую, можно не ловить исключения.</p>
<p>В серверах, обрабатывающих пользовательские запросы, как правило, достаточно ловить исключения на самом верху обработчика соединения.</p>
<p>В функциях потока, следует ловить и запоминать все исключения, чтобы выкинуть их в основном потоке после <code>join</code>.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">/// Если вычислений ещё не было - вычислим первый блок синхронно</div>
<div class="line">if (!started)</div>
<div class="line">{</div>
<div class="line">    calculate();</div>
<div class="line">    started = true;</div>
<div class="line">}</div>
<div class="line">else    /// Если вычисления уже идут - подождём результата</div>
<div class="line">    pool.wait();</div>
<div class="line"> </div>
<div class="line">if (exception)</div>
<div class="line">    exception-&gt;rethrow();</div>
</div><!-- fragment --><p>Ни в коем случае не «проглатывайте» исключения без разбора. Ни в коем случае, не превращайте все исключения без разбора в сообщения в логе.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//Not correct</div>
<div class="line">catch (...) {}</div>
</div><!-- fragment --><p>Если вам нужно проигнорировать какие-то исключения, то игнорируйте только конкретные, а остальные кидайте обратно.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">catch (const DB::Exception &amp; e)</div>
<div class="line">{</div>
<div class="line">    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)</div>
<div class="line">        return nullptr;</div>
<div class="line">    else</div>
<div class="line">        throw;</div>
<div class="line">}</div>
</div><!-- fragment --><p>При использовании функций, использующих коды возврата или <code>errno</code>, проверяйте результат и кидайте исключение.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">if (0 != close(fd))</div>
<div class="line">    throwFromErrno(&quot;Cannot close file &quot; + file_name, ErrorCodes::CANNOT_CLOSE_FILE);</div>
</div><!-- fragment --><p><code>assert</code> не используются.</p>
<p><b>4.</b> Типы исключений.</p>
<p>В прикладном коде не требуется использовать сложную иерархию исключений. Желательно, чтобы текст исключения был понятен.</p>
<p><b>5.</b> Исключения, вылетающие из деструкторов.</p>
<p>Использовать не рекомендуется, но допустимо.</p>
<p>Используйте следующие варианты:</p>
<ul>
<li>Сделайте функцию (<code>done()</code> или <code>finalize()</code>), которая позволяет заранее выполнить всю работу, в процессе которой может возникнуть исключение. Если эта функция была вызвана, то затем в деструкторе не должно возникать исключений.</li>
<li>Слишком сложную работу (например, отправку данных по сети) можно вообще не делать в деструкторе, рассчитывая, что пользователь заранее позовёт метод для завершения работы.</li>
<li>Если в деструкторе возникло исключение, желательно не «проглатывать» его, а вывести информацию в лог (если в этом месте доступен логгер).</li>
<li>В простых программах, если соответствующие исключения не ловятся, и приводят к завершению работы с записью информации в лог, можно не беспокоиться об исключениях, вылетающих из деструкторов, так как вызов <code>std::terminate</code> (в случае <code>noexcept</code> по умолчанию в C++11), является приемлемым способом обработки исключения.</li>
</ul>
<p><b>6.</b> Отдельные блоки кода.</p>
<p>Внутри одной функции, можно создать отдельный блок кода, для того, чтобы сделать некоторые переменные локальными в нём, и для того, чтобы соответствующие деструкторы были вызваны при выходе из блока.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">Block block = data.in-&gt;read();</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex);</div>
<div class="line">    data.ready = true;</div>
<div class="line">    data.block = block;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ready_any.set();</div>
</div><!-- fragment --><p><b>7.</b> Многопоточность.</p>
<p>В программах офлайн обработки данных:</p>
<ul>
<li>cначала добейтесь более-менее максимальной производительности на одном процессорном ядре, потом можно распараллеливать код, но только если есть необходимость.</li>
</ul>
<p>В программах - серверах:</p>
<ul>
<li>используйте пул потоков для обработки запросов. На данный момент, у нас не было задач, в которых была бы необходимость использовать userspace context switching.</li>
</ul>
<p>Fork для распараллеливания не используется.</p>
<p><b>8.</b> Синхронизация потоков.</p>
<p>Часто можно сделать так, чтобы отдельные потоки писали данные в разные ячейки памяти (лучше в разные кэш-линии), и не использовать синхронизацию потоков (кроме <code>joinAll</code>).</p>
<p>Если синхронизация нужна, то в большинстве случаев, достаточно использовать mutex под <code>lock_guard</code>.</p>
<p>В остальных случаях, используйте системные примитивы синхронизации. Не используйте busy wait.</p>
<p>Атомарные операции можно использовать только в простейших случаях.</p>
<p>Не нужно писать самостоятельно lock-free структуры данных.</p>
<p><b>9.</b> Ссылки и указатели.</p>
<p>В большинстве случаев, предпочитайте ссылки.</p>
<p><b>10.</b> const.</p>
<p>Используйте константные ссылки, указатели на константу, <code>const_iterator</code>, константные методы.</p>
<p>Считайте, что <code>const</code> — вариант написания «по умолчанию», а отсутствие <code>const</code> только при необходимости.</p>
<p>Для переменных, передающихся по значению, использовать <code>const</code> обычно не имеет смысла.</p>
<p><b>11.</b> unsigned.</p>
<p>Используйте <code>unsigned</code>, если нужно.</p>
<p><b>12.</b> Числовые типы.</p>
<p>Используйте типы <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code>, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code>, а также <code>size_t</code>, <code>ssize_t</code>, <code>ptrdiff_t</code>.</p>
<p>Не используйте для чисел типы <code>signed/unsigned long</code>, <code>long long</code>, <code>short</code>, <code>signed/unsigned char</code>, <code>char</code>.</p>
<p><b>13.</b> Передача аргументов.</p>
<p>Сложные значения передавайте по ссылке (включая <code>std::string</code>).</p>
<p>Если функция захватывает владение объектом, созданным на куче, то сделайте типом аргумента <code>shared_ptr</code> или <code>unique_ptr</code>.</p>
<p><b>14.</b> Возврат значений.</p>
<p>В большинстве случаев, просто возвращайте значение с помощью <code>return</code>. Не пишите <code>return std::move(res)</code>.</p>
<p>Если внутри функции создаётся объект на куче и отдаётся наружу, то возвращайте <code>shared_ptr</code> или <code>unique_ptr</code>.</p>
<p>В некоторых редких случаях, может потребоваться возвращать значение через аргумент функции. В этом случае, аргументом будет ссылка.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">using AggregateFunctionPtr = std::shared_ptr&lt;IAggregateFunction&gt;;</div>
<div class="line"> </div>
<div class="line">/** Позволяет создать агрегатную функцию по её имени.</div>
<div class="line">  */</div>
<div class="line">class AggregateFunctionFactory</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    AggregateFunctionFactory();</div>
<div class="line">    AggregateFunctionPtr get(const String &amp; name, const DataTypes &amp; argument_types) const;</div>
</div><!-- fragment --><p><b>15.</b> namespace.</p>
<p>Для прикладного кода отдельный <code>namespace</code> использовать не нужно.</p>
<p>Для маленьких библиотек - не требуется.</p>
<p>Для не совсем маленьких библиотек - поместите всё в <code>namespace</code>.</p>
<p>Внутри библиотеки в <code>.hpp</code> файле можно использовать <code>namespace detail</code> для деталей реализации, не нужных прикладному коду.</p>
<p>В <code>.cpp</code> файле можно использовать <code>static</code> или анонимный namespace для скрытия символов.</p>
<p>Используйте <code>enum class</code> вместо <code>enum</code>.</p>
<p><b>16.</b> Отложенная инициализация.</p>
<p>Обычно, если для инициализации требуются аргументы, то не пишите конструктор по умолчанию.</p>
<p>Если потом вам потребовалась отложенная инициализация, то вы можете дописать конструктор по умолчанию (который создаст объект с некорректным состоянием). Или, для небольшого количества объектов, можно использовать <code>shared_ptr/unique_ptr</code>.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">Loader(DB::Connection* connection_, const std::string&amp; query, size_t max_block_size_);</div>
<div class="line"> </div>
<div class="line">/// Для отложенной инициализации</div>
<div class="line">Loader() {}</div>
</div><!-- fragment --><p><b>17.</b> Виртуальные функции.</p>
<p>Если класс не предназначен для полиморфного использования, то не нужно делать функции виртуальными зря. Это относится и к деструктору.</p>
<p><b>18.</b> Кодировки.</p>
<p>Везде используется UTF-8. Используется <code>std::string</code>, <code>char*</code>. Не используется <code>std::wstring</code>, <code>wchar_t</code>.</p>
<p><b>19.</b> Логирование.</p>
<p>См. примеры везде в коде.</p>
<p>Перед коммитом, удалите всё бессмысленное и отладочное логирование, и другие виды отладочного вывода.</p>
<p>Не должно быть логирования на каждую итерацию внутреннего цикла, даже уровня Trace.</p>
<p>При любом уровне логирования, логи должно быть возможно читать.</p>
<p>Логирование следует использовать, в основном, только в прикладном коде.</p>
<p>Сообщения в логе должны быть написаны на английском языке.</p>
<p>Желательно, чтобы лог был как можно понятнее.</p>
<p>Не нужно писать ругательства в лог.</p>
<p>В логе используется кодировка UTF-8. Изредка можно использовать в логе не-ASCII символы.</p>
<p><b>20.</b> include.</p>
<p>В заголовочном файле используется только <code>#pragma once</code>, а include guards писать не нужно.</p>
<p>В первую очередь подключайте внешние зависимости, и только потом внутренние.</p>
<p>Разделяйте подключаемые модули на группы: </p><div class="fragment"><div class="line"> cpp</div>
<div class="line">#include &lt;external_module1&gt;</div>
<div class="line">#include &lt;external_module1&gt;</div>
<div class="line">//...</div>
<div class="line"> </div>
<div class="line">#include &quot;internal_module1&quot;</div>
<div class="line">#include &quot;internal_module2&quot;</div>
<div class="line">//...</div>
</div><!-- fragment --><p><b>21.</b> using.</p>
<p><code>using namespace</code> не используется. Можно использовать <code>using</code> что-то конкретное. Лучше локально, внутри класса или функции.</p>
<p><b>22.</b> Не нужно использовать <code>trailing return type</code> для функций, если в этом нет необходимости.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">auto f() -&gt; void</div>
</div><!-- fragment --><p><b>23.</b> Объявление и инициализация переменных.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">//right way</div>
<div class="line">std::string s = &quot;Hello&quot;;</div>
<div class="line">std::string s{&quot;Hello&quot;};</div>
<div class="line"> </div>
<div class="line">//wrong way</div>
<div class="line">auto s = std::string{&quot;Hello&quot;};</div>
</div><!-- fragment --><p><b>24.</b> Для виртуальных функций, пишите <code>virtual</code> в базовом классе, а в классах-наследниках, пишите <code>override</code> и не пишите <code>virtual</code>.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Неиспользуемые возможности языка C++</h2>
<p><b>25.</b> Спецификаторы исключений из C++03 не используются.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Сообщения об ошибках</h2>
<p>Сообщения об ошибках &ndash; это часть пользовательского интерфейса программы, предназначенная для того, чтобы позволить пользователю:</p>
<ul>
<li>замечать ошибочные ситуации,</li>
<li>понимать их смысл и причины,</li>
<li>устранять эти ситуации.</li>
</ul>
<p>Форма и содержание сообщений об ошибках должны способствовать достижению этих целей.</p>
<p>Есть два основных вида ошибок:</p>
<ul>
<li>пользовательская или системная ошибка,</li>
<li>внутренняя программная ошибка.</li>
</ul>
<h3><a class="anchor" id="autotoc_md50"></a>
Пользовательская ошибка</h3>
<p>Такая ошибка вызвана действиями пользователя (неверный синтаксис запроса) или конфигурацией внешних систем (кончилось место на диске). Предполагается, что пользователь может устранить её самостоятельно. Для этого в сообщении об ошибке должна содержаться следующая информация:</p>
<ul>
<li>что произошло. Это должно объясняться в пользовательских терминах (<code>Function pow() is not supported for data type UInt128</code>), а не загадочными конструкциями из кода (<code>runtime overload resolution failed in DB::BinaryOperationBuilder&lt;FunctionAdaptor&lt;pow&gt;::Impl, UInt128, Int8&gt;::kaboongleFastPath()</code>).</li>
<li>почему/где/когда &ndash; любой контекст, который помогает отладить проблему. Представьте, как бы её отлаживали вы (программировать и пользоваться отладчиком нельзя).</li>
<li>что можно предпринять для устранения ошибки. Здесь можно перечислить типичные причины проблемы, настройки, влияющие на это поведение, и так далее.</li>
</ul>
<p>Пример нормального сообщения: </p><div class="fragment"><div class="line">No alias for subquery or table function in JOIN (set joined_subquery_requires_alias=0 to disable restriction).</div>
<div class="line">While processing &#39;(SELECT 2 AS a)&#39;.</div>
</div><!-- fragment --><p> Сказано что не хватает алиаса, показано, для какой части запроса, и предложена настройка, позволяющая ослабить это требование.</p>
<p>Пример катастрофически плохого сообщения: </p><div class="fragment"><div class="line">The dictionary is configured incorrectly.</div>
</div><!-- fragment --><p> Из него не понятно:</p>
<ul>
<li>какой словарь?</li>
<li>в чём ошибка конфигурации?</li>
</ul>
<p>Что может сделать пользователь в такой ситуации: применять внешние отладочные инструменты, спрашивать совета на форумах, гадать на кофейной гуще, и, конечно же, ненавидеть софт, который над ним так издевается. Не нужно издеваться над пользователями, это плохой UX.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
Внутренняя программная ошибка</h3>
<p>Такая ошибка вызвана нарушением внутренних инвариантов программы: например, внутренняя функция вызвана с неверными параметрами, не совпадают размеры колонок в блоке, произошло разыменование нулевого указателя, и так далее. Сигналы типа <code>SIGSEGV</code> относятся к этой же категории.</p>
<p>Появление такой ошибки всегда свидетельствует о наличии бага в программе. Пользователь не может исправить такую ошибку самостоятельно, и должен сообщить о ней разработчикам.</p>
<p>Есть два основных варианта проверки на такие ошибки:</p>
<ul>
<li>Исключение с кодом <code>LOGICAL_ERROR</code>. Его можно использовать для важных проверок, которые делаются в том числе в релизной сборке.</li>
<li><code>assert</code>. Такие условия не проверяются в релизной сборке, можно использовать для тяжёлых и опциональных проверок.</li>
</ul>
<p>Пример сообщения, у которого должен быть код <code>LOGICAL_ERROR</code>: <code>Block header is inconsistent with Chunk in ICompicatedProcessor::munge(). It is a bug!</code> По каким признакам можно заметить, что здесь говорится о внутренней программной ошибке?</p>
<ul>
<li>в сообщении упоминаются внутренние сущности из кода,</li>
<li>в сообщении написано it's a bug,</li>
<li>непосредственные действия пользователя не могут исправить эту ошибку. Мы ожидаем, что пользователь зарепортит её как баг, и будем исправлять в коде.</li>
</ul>
<h3><a class="anchor" id="autotoc_md52"></a>
Как выбрать код ошибки?</h3>
<p>Код ошибки предназначен для автоматической обработки некоторых видов ошибок, подобно кодам HTTP. Можно использовать общие коды типа <code>BAD_ARGUMENTS</code> или <code>TYPE_MISMATCH</code>. Заводить новый код нужно, если вы чётко понимаете, что вам нужна специальная автоматическая обработка конкретно этой ошибки. Для внутренних программных ошибок используется код <code>LOGICAL_ERROR</code>.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
Как добавить новое сообщение об ошибке?</h3>
<p>Когда добавляете сообщение об ошибке:</p>
<ol type="1">
<li>Опишите, что произошло, в пользовательских терминах, а не кусками кода.</li>
<li>Добавьте максимум контекста (с чем произошло, когда, почему, и т.д.).</li>
<li>Добавьте типичные причины.</li>
<li>Добавьте варианты исправления (настройки, ссылки на документацию).</li>
<li>Вообразите дальнейшие действия пользователя. Ваше сообщение должно помочь ему решить проблему без использования отладочных инструментов и без чужой помощи.</li>
<li>Если сообщение об ошибке не формулируется в пользовательских терминах, и действия пользователя не могут исправить проблему &ndash; это внутренняя программная ошибка, используйте код LOGICAL_ERROR или assert.</li>
</ol>
<h2><a class="anchor" id="autotoc_md54"></a>
Платформа</h2>
<p><b>1.</b> Мы пишем код под конкретные платформы.</p>
<p>Хотя, при прочих равных условиях, предпочитается более-менее кроссплатформенный или портируемый код.</p>
<p><b>2.</b> ОС - Linux, [Mac OS], Windows.</p>
<p><b>3.</b> Используются флаги компиляции <code>-Wall -Wextra -Werror</code> и <code>-Weverything</code>.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Инструментарий</h2>
<p><b>1.</b> Cреда разработки - [VS2019, Clion, Qt]</p>
<p><b>2.</b> Исходники в Git.</p>
<p><b>3.</b> Сборка с помощью <code>CMake</code>.</p>
<p><b>4.</b> Коммиты только в вашу ветку, исключая специфичные случаи ;)</p>
<p>А работоспособность собранных программ гарантируется только для отдельных ревизий.</p>
<p><b>8.</b> Коммитьте как можно чаще, в том числе и нерабочий код.</p>
<p>Для этого следует использовать бранчи.</p>
<p><b>9.</b> Для нетривиальных изменений, используются бранчи. Следует загружать бранчи на сервер.</p>
<p><b>10.</b> Ненужный код удаляется из исходников.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Библиотеки</h2>
<p><b>1.</b> При необходимости, можно использовать любые известные библиотеки, доступные в ОС из пакетов.</p>
<p>Если есть хорошее готовое решение, то оно используется, даже если для этого придётся установить ещё одну библиотеку.</p>
<p>(Будьте готовы к тому, что иногда вам придётся выкидывать плохие библиотеки из кода.)</p>
<p><b>2.</b> Если в пакетах нет нужной библиотеки, или её версия достаточно старая, или если она собрана не так, как нужно, то можно использовать библиотеку, устанавливаемую не из пакетов.</p>
<p><b>3.</b> Если библиотека достаточно маленькая и у неё нет своей системы сборки, то следует включить её файлы в проект, в директорию <code>contrib</code>.</p>
<p><b>4.</b> Предпочтение всегда отдаётся уже использующимся библиотекам.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Общее</h2>
<p><b>1.</b> Пробуйте самое простое решение.</p>
<p><b>2.</b> Не нужно писать код, если вы ещё не знаете, что будет делать ваша программа, и как будет работать её внутренний цикл.</p>
<p><b>3.</b> В простейших случаях, используйте <code>using</code> вместо классов/структур.</p>
<p><b>4.</b> Если есть возможность - не пишите конструкторы копирования, операторы присваивания, деструктор (кроме виртуального, если класс содержит хотя бы одну виртуальную функцию), move-конструкторы и move-присваивания. То есть, чтобы соответствующие функции, генерируемые компилятором, работали правильно. Можно использовать <code>default</code>.</p>
<p><b>5.</b> Приветствуется упрощение и уменьшение объёма кода.</p>
<h2><a class="anchor" id="dopolnitelno"></a>
Дополнительно</h2>
<p><b>1.</b> Явное указание <code>std::</code> для типов <code>std::size_t</code> вместо <code>size_t</code>, это короче хорошо</p>
<p><b>2.</b> Явное указание <code>std::</code> для функций из стандартной библиотеки C.</p>
<p>То есть, пишите <code>std::memcpy</code> вместо <code>memcpy</code>.</p>
<p><b>3.</b> Использование функций из C при наличии аналогов в стандартной библиотеке C++.</p>
<p>Допустимо, если это использование эффективнее.</p>
<p>Опционально. Для примера, для копирования длинных кусков памяти, используйте <code>memcpy</code> вместо <code>std::copy</code>.</p>
<p><b>4.</b> Перенос длинных аргументов функций.</p>
<p>Допустимо использовать любой стиль переноса, похожий на приведённые ниже:</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">function(</div>
<div class="line">  T1 x1,</div>
<div class="line">  T2 x2)</div>
</div><!-- fragment --><div class="fragment"><div class="line"> cpp</div>
<div class="line">function(</div>
<div class="line">  size_t left, size_t right,</div>
<div class="line">  const &amp; RangesInDataParts ranges,</div>
<div class="line">  size_t limit)</div>
</div><!-- fragment --><div class="fragment"><div class="line"> cpp</div>
<div class="line">function(size_t left, size_t right,</div>
<div class="line">  const &amp; RangesInDataParts ranges,</div>
<div class="line">  size_t limit)</div>
</div><!-- fragment --><div class="fragment"><div class="line"> cpp</div>
<div class="line">function(size_t left, size_t right,</div>
<div class="line">      const &amp; RangesInDataParts ranges,</div>
<div class="line">      size_t limit)</div>
</div><!-- fragment --><div class="fragment"><div class="line"> cpp</div>
<div class="line">function(</div>
<div class="line">      size_t left,</div>
<div class="line">      size_t right,</div>
<div class="line">      const &amp; RangesInDataParts ranges,</div>
<div class="line">      size_t limit)</div>
</div><!-- fragment --><p><a href="https://clickhouse.tech/docs/ru/development/style/">Оригинальная статья</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

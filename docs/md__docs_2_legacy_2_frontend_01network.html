<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Juniorgram: Description of several classes:</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="juniorgram_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Juniorgram<span id="projectnumber">&#160;0.6</span>
   </div>
   <div id="projectbrief">C++ written messenger! Never before and never again!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Description of several classes:</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md17"></a> </p>
<h1><a class="anchor" id="autotoc_md18"></a>
Connection</h1>
<h3><a class="anchor" id="autotoc_md19"></a>
Attributes:</h3>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line">OwnerType mOwner = OwnerType::SERVER </div>
</div><!-- fragment --><p> the "owner" decides how some of the connection behaves.</p>
<hr  />
<div class="fragment"><div class="line">++</div>
<div class="line">uint64_t mID = uint64_t()</div>
</div><!-- fragment --><p> connection ID.</p>
<hr  />
<div class="fragment"><div class="line">asio::ip::tcp::socket mSocket </div>
</div><!-- fragment --><p> Each connection has a unique socket to a remote.</p>
<hr  />
<p>asio::io_context&amp; mContextLink - this context is shared with the whole asio instance.</p>
<hr  />
<p>SafeQueue&lt;Message&gt;&amp; mIncomingMessagesQueueLink - this references the incoming queue of the parent object.</p>
<hr  />
<p>SafeQueue&lt;Message&gt; mOutcomingMessagesQueue - this queue holds all messages to be sent to the remote side of this connection.</p>
<hr  />
<p>Message mMessageBuffer - incoming messages are constructed asynchronously, so we will store the part assembled message here, until it is ready</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Methods:</h2>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> writeHeader() </div>
</div><!-- fragment --><p> this func. suggests that we have messages we want to send. And we use the function asio::async_write(mSocket, asio::buffer(&amp;mOutcomingMessagesQueue.front().mHeader, sizeof(Message::MessageHeader)) to write the header of the message to the socket.</p>
<p>if the writing header to the socket failed, we display an error message - "[&lt;clientID&gt; ] Write Header Fail." Otherwise, we try to write the body of the message if it is not empty. If it is empty, then we remove the current message from the message queue to send and take the following header from queue and then write the body.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> writeBody() </div>
</div><!-- fragment --><p> if the writing body to the socket failed, we display an error message - "[&lt;clientID&gt; ] Write Body Fail." Otherwise, we remove the message from queue using mOutcomingMessagesQueue.pop_front(), and if queue isn't empty - try to write the header of the message.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> readHeader() </div>
</div><!-- fragment --><p> using this func we are getting header from socket. If it possible - further we resize the messages body vector and call ReadBody(). Otherwise, we have header.size &lt;= 0 and add the bodyless message to the connections incoming message queue. if reading body from socket failed, we display an error message - "[&lt;clientID&gt; ] Read Header Fail."</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> readBody()</div>
</div><!-- fragment --><p> If this function is called, a header has been read, and that header request we read a body, The space for that body has already been allocated in the temporary message object, so just wait for the bytes to arrive. Next we call AddToIncomingMessageQueue() for adding message in queue. If we can't read the body from the socket we display an error message - "[&lt;clientID&gt; ] Read Body Fail."</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> addToIncomingMessageQueue() </div>
</div><!-- fragment --><p> once a full message is received, add it to the incoming queue. Shove it in queue, converting it to an "owned message", by initializing with the a shared pointer from this connection object for <a class="el" href="class_server.html" title="This class does all logic which is needed to run the server.">Server</a> side and without shared pointer from this for Client side. Next we call ReadHeader() to read other messages.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line">Connection(<span class="keyword">const</span> OwnerType&amp; owner, asio::io_context&amp; contextLink, asio::ip::tcp::socket socket, SafeQueue&lt;Message&gt;&amp; incomingMessagesQueueLink)</div>
</div><!-- fragment --><p> specify owner, connect to context, transfer the socket provide reference to incoming message queue.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> uint64_t&amp; getID() const </div>
</div><!-- fragment --><p> this ID is used system wide - its how clients will understand other clients whole system.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> connectToClient(<span class="keyword">const</span> uint64_t&amp; uid = uint64_t()) </div>
</div><!-- fragment --><p> this func allows only <a class="el" href="class_server.html" title="This class does all logic which is needed to run the server.">Server</a> side connect to other Clients.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> connectToServer(<span class="keyword">const</span> asio::ip::tcp::resolver::results_type&amp; endpoint) </div>
</div><!-- fragment --><p> only clients can connect to servers. And make a request asio attempts to connect to an endpoint.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> disconnect() </div>
</div><!-- fragment --><p> check if we have connection with smb/smth. If we have connection we call asio::post, because the current context is holding locks and you want the function to be called after they have been released. This would allow the function to acquire those locks itself without causing a deadlock.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> isConnected() const </div>
</div><!-- fragment --><p> check if current socket is open.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> send(<span class="keyword">const</span> Message&amp; message) </div>
</div><!-- fragment --><p> send a message, connections are one-to-one so no need to specifiy the target, for a Client, the target is the <a class="el" href="class_server.html" title="This class does all logic which is needed to run the server.">Server</a> and vice versa.</p>
<p>If the queue has a message in it, then we must assume that it is in the process of asynchronously being written. Either way add the message to the queue to be output. If no messages were available to be written, then start the process of writing the message at the front of the queue.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Message</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Attributes:</h2>
<p>std::shared_ptr&lt;Connection&gt; mRemote = nullptr - on a server, the owner would be the client that sent the message, on a client the owner would be the server.</p>
<p>MessageHeader mHeader - header of the message.</p>
<p>std::vector&lt;uint8_t&gt; mBody - contain a raw bytes information. </p><hr  />
<h2><a class="anchor" id="autotoc_md23"></a>
Methods:</h2>
<p>size_t size() const - returns size of entire message packet in bytes.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">friend</span> std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Message&amp; message) </div>
</div><!-- fragment --><p> override for std::cout compatibility - produces friendly description of message</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">friend</span> Message&amp; operator &lt;&lt;(Message&amp; message, <span class="keyword">const</span> T&amp; data) </div>
</div><!-- fragment --><p> pushes any POD-like data into the message buffer.</p>
<p>Check that the type of the data being pushed is trivially copyable. Check that the type of the data being pushed is trivially copyable. Resize the vector by the size of the data being pushed. Physically copy the data into the newly allocated vector space. Recalculate the message size. Recalculate the message size.</p>
<hr  />
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">friend</span> Message&amp; operator &gt;&gt;(Message&amp; message, T&amp; data) </div>
</div><!-- fragment --><p> pulls any POD-like data form the message buffer.</p>
<p>Check that the type of the data being pushed is trivially copyable. Cache the location towards the end of the vector where the pulled data starts. Physically copy the data from the vector into the user variable. Shrink the vector to remove read bytes, and reset end position. Recalculate the message size. Return the target message so it can be "chained".</p>
<p>Message::MessageHeader</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Message Header is sent at start of all messages.</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Attributes</h2>
<p>MessageType mID = MessageType() - message ID</p>
<p>uint32_t mBodySize = uint32_t() - current size of message part.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
MessageType</h2>
<p>ServerAccept - server has accepted a connection.</p>
<p>ServerPing - the time response from server.</p>
<p>MessageAll - to send a message to all clients.</p>
<p>ServerMessage - (plug) some message for server.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Diagrams</h1>
<p><img src="../images/image%20(1).png" alt="" class="inline"/> <br  />
 <img src="../images/image.png" alt="" class="inline"/> <br  />
 <img src="../images/image%20(6).png" alt="" class="inline"/> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Juniorgram: Deeping intro ASIO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="juniorgram_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Juniorgram<span id="projectnumber">&#160;0.6</span>
   </div>
   <div id="projectbrief">C++ written messenger! Never before and never again!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Deeping intro ASIO</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>I/O operations.<br  />
Boost.Asio</h1>
<h4>CONTENT </h4>
<p><a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#IOoperations">1. I/O operations</a> <br  />
 <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#dataIntegrity">2. Data integrity</a> <br  />
 <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#errorHandling">3. Error and exception handling</a> <br  />
 <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#bigFileTransmissions">4. Big file transmissions</a> <br  />
 <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#bigProjects">5. Usage in Open Source projects</a> <br  />
 <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#toRead">6. To read</a> <br  />
</p>
<p><a class="anchor" id="IOoperations"></a></p><h2>@ref "1" "I/O operations"</h2>
<p><em>I will consider everything with the example of asynchronous networking over TCP/IP. <br  />
 </em></p>
<p>There are several functions for writing and reading operations:</p>
<p>Basis functions that perform the I/O on the socket:</p><ul>
<li><code>async_read_some(buffer, handler)</code></li>
<li><code>async_write_some(buffer)</code></li>
</ul>
<p>Basis functions that read from or write to a stream:</p><ul>
<li><code>async_read(stream, buffer [, completion], handler)</code></li>
<li><code>async_write(stream, buffer [, completion], handler)</code></li>
</ul>
<p>First, note that the first argument is a stream. This includes sockets but is not limited. For instance, instead of a socket, you can use a Windows file handle.</p>
<p>Each read or write operation will end when one of these conditions occur:</p><ul>
<li>The supplied buffer is full (for read) or all the data in the buffer has been written (for write)</li>
<li>The completion function returns 0 (if you supplied one such function)</li>
<li>An error occurs</li>
</ul>
<p><a class="anchor" id="comletion"></a></p><h3>The completion </h3>
<p>Signature: </p><div class="fragment"><div class="line"> ++ </div>
<div class="line"><span class="keywordtype">size_t</span> completion(<span class="keyword">const</span> boost::system::error_code&amp; err, <span class="keywordtype">size_t</span> bytes_transfered);</div>
</div><!-- fragment --><p>A completion condition is a function object that is used with the algorithms <code>read</code>, <code>async_read</code>, <code>write</code>, and </p><div class="fragment"><div class="line">_write</div>
</div><!-- fragment --><p> to determine when the algorithm has completed transferring data.</p>
<p>You can optionally specify a completion function. It is called after each successful read, and tells Boost.Asio if the <code>async_read</code> operation is complete (if not, it will continue to read).</p>
<p>When this completion function returns 0, we consider the read operation complete.</p>
<p>If it returns a non-zero value, it indicates the maximum number of bytes to be read on the next call to the stream's <code>async_read_some</code> operation.</p>
<p>Boost.Asio comes with a few helper completion functors as well:</p><ul>
<li>transfer_at_least(n)</li>
<li>transfer_exactly(n)</li>
<li>transfer_all()</li>
</ul>
<p><a class="anchor" id="handler"></a></p><h3>The handler </h3>
<p>Signature: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> handler(<span class="keyword">const</span> boost::system::error_code&amp; err, <span class="keywordtype">size_t</span> bytes_transfered);</div>
</div><!-- fragment --><p>Each asynchronous operation has a handler, a function that is called when the operation has completed.</p>
<p>For example, the <code>asio::async_read()</code> function initiates the operation that reads the data from the socket until the buffer passed to it as an argument is full. In this case, the callback (in our case itâ€™s called handler) is called when the amount of data read is equal to the size of the provided buffer or when an error occurs.</p>
<p>You can specify your own handler implementation and bind it with async_read.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// Alias for the error handler functor</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> myHandler = [<span class="keyword">this</span>](std::error_code error) {</div>
<div class="line">       <span class="comment">// realization</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">asio::async_read(stream, socket,</div>
<div class="line">                      bind(myHandler, std::placeholders::_1)); </div>
</div><!-- fragment --><p><a class="anchor" id="reading"></a></p><h3>@ref "1" "Reading from a TCP socket asynchronously" </h3>
<p><a class="anchor" id="async_read_some"></a></p><h4>async_read_some() </h4>
<p>The most basic tool used to asynchronously read data from a TCP socket provided by the Boost.Asio library is the <code>async_read_some()</code> method of the <code>asio::ip::tcp::socket</code> class.</p>
<p>Here is one of the method's overloads: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> MutableBufferSequence,</div>
<div class="line">    <span class="keyword">typename</span> ReadHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_read_some(</div>
<div class="line">    <span class="keyword">const</span> MutableBufferSequence &amp; buffers,</div>
<div class="line">    ReadHandler handler);</div>
</div><!-- fragment --><p>The <code>async_read_some()</code> method initiates an operation that is intended to read some amount of data from the socket to the buffer. This method guarantees that <b>at least one byte</b> will be read during the corresponding asynchronous operation if an error does not occur. This means that, in a general case, in order to read all the data from the socket, we may need to perform this asynchronous operation several times.</p>
<h5>Algorithm </h5>
<p>The following algorithm describes the steps required to implement an application, which reads data from a socket asynchronously. Note that this algorithm provides a possible way to implement such an application.</p>
<ol type="1">
<li>Define a data structure that contains a pointer to a socket object, a buffer, a variable that defines the size of the buffer, and a variable used as a counter of bytes read.</li>
<li>Define a callback function that will be called when an asynchronous reading operation is completed.</li>
<li>In a client application, allocate and open an active TCP socket, and then, connect it to a remote application. In a server application, obtain a connected active TCP socket by accepting a connection request.</li>
<li>Allocate a buffer big enough for the expected message to fit in.</li>
<li>Initiate an asynchronous reading operation by calling the socket's async_read_ some() method, specifying a function defined in step 2 as a callback.</li>
<li>Call the run() method on an object of the asio::io_service class.</li>
<li>In a callback, increase the counter of bytes read. If the number of bytes read is less than the total amount of bytes to be read (that is, the size of an expected message), initiate a new asynchronous reading operation to read the next portion of data.</li>
</ol>
<h4>Code example </h4>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;asio.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1.</span></div>
<div class="line"><span class="comment">// Keeps objects we need in a callback to identify whether all data has been read from the socket and to</span></div>
<div class="line"><span class="comment">// initiate next async reading operation if needed.</span></div>
<div class="line"><span class="keyword">struct </span>Session </div>
<div class="line">{</div>
<div class="line">      std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;</div>
<div class="line">      std::unique_ptr&lt;char[]&gt; buf;</div>
<div class="line">      std::size_t total_bytes_read;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> buf_size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2.</span></div>
<div class="line"><span class="comment">// Function used as a callback for asynchronous reading operation. Check if all data has been read from the</span></div>
<div class="line"><span class="comment">// socket and initiates new reading operation if needed.</span></div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> asio::error_code&amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;Session&gt; s) </div>
<div class="line">{</div>
<div class="line">      <span class="keywordflow">if</span> (ec.value() != 0) </div>
<div class="line">      {</div>
<div class="line">        logging::get()-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, ec.value(), ec.message());</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 7. Increasing the counter  of bytes read.</span></div>
<div class="line">      s-&gt;total_bytes_read += bytes_transferred;</div>
<div class="line">      <span class="keywordflow">if</span> (s-&gt;total_bytes_read == s-&gt;buf_size) </div>
<div class="line">      {</div>
<div class="line">        logging::get()-&gt;info(<span class="stringliteral">&quot;Total Bytes Read = {}&quot;</span>, s-&gt;total_bytes_read);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      s-&gt;sock-&gt;async_read_some(</div>
<div class="line">          asio::buffer(s-&gt;buf.get() + s-&gt;total_bytes_read, s-&gt;buf_size - s-&gt;total_bytes_read),</div>
<div class="line">          std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> readFromSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock) </div>
<div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> s = std::make_shared&lt;Session&gt;();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 4. Allocating the buffer;</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MESSAGE_SIZE = 7;</div>
<div class="line"> </div>
<div class="line">      s-&gt;buf.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[MESSAGE_SIZE]);</div>
<div class="line">      s-&gt;total_bytes_read = 0;</div>
<div class="line">      s-&gt;sock = sock;</div>
<div class="line">      s-&gt;buf_size = MESSAGE_SIZE;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 5. Initiating asynchronous reading operation.</span></div>
<div class="line">      s-&gt;sock-&gt;async_read_some(asio::buffer(s-&gt;buf.get(), s-&gt;buf_size),</div>
<div class="line">                               std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> console = logging::setup();</div>
<div class="line"> </div>
<div class="line">      std::string raw_ip_address = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port_num = 3333;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">try</span> </div>
<div class="line">      {</div>
<div class="line">        asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num);</div>
<div class="line">        asio::io_service ios;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 3. Allocating, opening and connecting a socket.</span></div>
<div class="line">        <span class="keyword">auto</span> sock = std::make_shared&lt;asio::ip::tcp::socket&gt;(ios, ep.protocol());</div>
<div class="line">        sock-&gt;connect(ep);</div>
<div class="line"> </div>
<div class="line">        readFromSocket(sock);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 6.</span></div>
<div class="line">        ios.run();</div>
<div class="line"> </div>
<div class="line">      } </div>
<div class="line">      <span class="keywordflow">catch</span> (asio::system_error&amp; e) </div>
<div class="line">      {</div>
<div class="line">        console-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, e.code(), e.what());</div>
<div class="line">        <span class="keywordflow">return</span> e.code().value();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The read operation <code>async_read_some</code> may not read all of the requested number of bytes. Consider using the <code>async_read</code> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</p>
<p>In last boost standards this function is <b>deduced</b>. More information you can see in <a href="https://www.boost.org/doc/libs/1_76_0/doc/html/boost_asio/reference/basic_stream_socket/async_read_some.html">Boost Documentation</a>.</p>
<p><a class="anchor" id="async_read"></a></p><h4>async_read() </h4>
<p>Although the async_read_some() method allows asynchronously reading data from the socket or the stream, the solution based on it is somewhat complex and error-prone. Fortunately, Boost.Asio provides a more convenient way to asynchronously read data from a socket: the free function <code>asio::async_read()</code>.</p>
<p>Use the <code>async_read</code> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</p>
<p>Let's consider one of its overloads: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> AsyncReadStream,</div>
<div class="line">    <span class="keyword">typename</span> MutableBufferSequence,</div>
<div class="line">    <span class="keyword">typename</span> ReadHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_read(</div>
<div class="line">    AsyncReadStream &amp; s,</div>
<div class="line">    <span class="keyword">const</span> MutableBufferSequence &amp; buffers,</div>
<div class="line">    ReadHandler handler);</div>
</div><!-- fragment --><p>More overloads you can see in <a href="https://www.boost.org/doc/libs/1_76_0/doc/html/boost_asio/reference/async_read.html">Boost Documentation</a>.</p>
<h4>Algorithm </h4>
<p>The asynchronous reading algorithm is the same as when using the function <code>async_read_some</code> except for item 7 of the algorithm. It doesn't exists.</p>
<h4>Code example </h4>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;asio.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1.</span></div>
<div class="line"><span class="comment">// Keeps objects we need in a callback to identify whether all data has been read from the socket and to</span></div>
<div class="line"><span class="comment">// initiate next async reading operation if needed.</span></div>
<div class="line"><span class="keyword">struct </span>Session </div>
<div class="line">{</div>
<div class="line">      std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;</div>
<div class="line">      std::unique_ptr&lt;char[]&gt; buf;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> buf_size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2.</span></div>
<div class="line"><span class="comment">// Function used as a callback for asynchronous reading operation. Checks if all data has been read from the</span></div>
<div class="line"><span class="comment">// socket and initiates new readnig operation if needed.</span></div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> asio::error_code&amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;Session&gt; s) </div>
<div class="line">{</div>
<div class="line">      <span class="keywordflow">if</span> (ec.value() != 0) </div>
<div class="line">      {</div>
<div class="line">        logging::get()-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, ec.value(), ec.message());</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Here we know that the reading has completed successfully and the buffer is full with data read from the</span></div>
<div class="line">      <span class="comment">// socket.</span></div>
<div class="line">      logging::get()-&gt;info(<span class="stringliteral">&quot;Total Bytes Read = {}&quot;</span>, bytes_transferred);</div>
<div class="line">      logging::get()-&gt;info(<span class="stringliteral">&quot;Message: {}&quot;</span>, std::string(s-&gt;buf.get()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> readFromSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock) </div>
<div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> s = std::make_shared&lt;Session&gt;();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MESSAGE_SIZE = 7;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 4. Allocating the buffer.</span></div>
<div class="line">      s-&gt;buf.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[MESSAGE_SIZE]);</div>
<div class="line">      s-&gt;sock = sock;</div>
<div class="line">      s-&gt;buf_size = MESSAGE_SIZE;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 5. Initiating asynchronous reading opration.</span></div>
<div class="line">      asio::async_read(*sock, asio::buffer(s-&gt;buf.get(), s-&gt;buf_size),</div>
<div class="line">                       std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> console = logging::setup();</div>
<div class="line"> </div>
<div class="line">      std::string raw_ip_address = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port_num = 3333;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">try</span> </div>
<div class="line">      {</div>
<div class="line">        asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num);</div>
<div class="line">        asio::io_service ios;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 3. Allocating, opening and connecting a socket.</span></div>
<div class="line">        <span class="keyword">auto</span> sock = std::make_shared&lt;asio::ip::tcp::socket&gt;(ios, ep.protocol());</div>
<div class="line">        sock-&gt;connect(ep);</div>
<div class="line"> </div>
<div class="line">        readFromSocket(sock);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 6.</span></div>
<div class="line">        ios.run();</div>
<div class="line">      } </div>
<div class="line">      <span class="keywordflow">catch</span> (asio::system_error&amp; e) </div>
<div class="line">      {</div>
<div class="line">        console-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, e.code(), e.what());</div>
<div class="line">        <span class="keywordflow">return</span> e.code().value();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="writting"></a></p><h3>Writing to a TCP socket asynchronously </h3>
<p><a class="anchor" id="async_write_some"></a></p><h4>async_write_some() </h4>
<p>The most basic tool used to asynchronously write data to the socket provided by the Boost. Asio library is the <code>async_write_some()</code> method of the <code>asio::ip::tcp::socket</code> class. Let's take a look at one of the method's overloads:</p>
<div class="fragment"><div class="line"> ++ </div>
<div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> ConstBufferSequence,</div>
<div class="line">    <span class="keyword">typename</span> WriteHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_write_some(</div>
<div class="line">    <span class="keyword">const</span> ConstBufferSequence &amp; buffers,</div>
<div class="line">    WriteHandler handler);</div>
</div><!-- fragment --><p>The <code>async_write_some()</code> method initiates an operation that is intended to write some amount of data from the buffer to the socket. This method guarantees that at least one byte will be written during the corresponding asynchronous operation if an error does not occur. This means that, in a general case, in order to write all the data available in the buffer to the socket, we may need to perform this asynchronous operation several times.</p>
<h5>Algorithm </h5>
<p>The following algorithm describes the steps required to perform and implement an application, which writes data to a TCP socket asynchronously. Note that this algorithm provides a possible way to implement such an application.</p>
<ol type="1">
<li>Define a data structure that contains a pointer to a socket object, a buffer, and a variable used as a counter of bytes written.</li>
<li>Define a callback function that will be called when the asynchronous writing operation is completed.</li>
<li>In a client application, allocate and open an active TCP socket and connect it to a remote application. In a server application, obtain a connected active TCP socket by accepting a connection request.</li>
<li>Allocate a buffer and fill it with data that is to be written to the socket.</li>
<li>Initiate an asynchronous writing operation by calling the socket's async_write_ some() method. Specify a function defined in step 2 as a callback.</li>
<li>Call the run() method on an object of the asio::io_service class.</li>
<li>In a callback, increase the counter of bytes written. If the number of bytes written is less than the total amount of bytes to be written, initiate a new asynchronous writing operation to write the next portion of the data.</li>
</ol>
<h5>Code example </h5>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;asio.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1.</span></div>
<div class="line"><span class="comment">// Keeps objects we need in a callback to identify whether all data has been written to the socket and to</span></div>
<div class="line"><span class="comment">// initiate next async writing operation if needed.</span></div>
<div class="line"><span class="keyword">struct </span>Session {</div>
<div class="line">      std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;</div>
<div class="line">      std::string buf;</div>
<div class="line">      std::size_t total_bytes_written;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2.</span></div>
<div class="line"><span class="comment">// Function used as a callback for asynchronous writing operation. Checks if all data from the buffer has been</span></div>
<div class="line"><span class="comment">// written to the socket and initiates new asynchronous writing operation if needed.</span></div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> asio::error_code&amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;Session&gt; s) </div>
<div class="line">{</div>
<div class="line">      <span class="keywordflow">if</span> (ec.value() != 0) </div>
<div class="line">      {</div>
<div class="line">        logging::get()-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, ec.value(), ec.message());</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 7. Increasing y=the counter of bytes written.</span></div>
<div class="line">      s-&gt;total_bytes_written += bytes_transferred;</div>
<div class="line">      <span class="keywordflow">if</span> (s-&gt;total_bytes_written == s-&gt;buf.length()) </div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      s-&gt;sock-&gt;async_write_some(</div>
<div class="line">          asio::buffer(s-&gt;buf.c_str() + s-&gt;total_bytes_written, s-&gt;buf.length() - s-&gt;total_bytes_written),</div>
<div class="line">          std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> writeToSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock) </div>
<div class="line">{</div>
<div class="line">      <span class="comment">// We need the Session object allocated it in the free memory and not on the stack; it must live until the</span></div>
<div class="line">      <span class="comment">// callback function is called.</span></div>
<div class="line">      <span class="keyword">auto</span> s = std::make_shared&lt;Session&gt;();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 4. Allocating and filling the buffer.</span></div>
<div class="line">      s-&gt;buf = std::string(<span class="stringliteral">&quot;Hello\n&quot;</span>);</div>
<div class="line">      s-&gt;total_bytes_written = 0;</div>
<div class="line">      s-&gt;sock = sock;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 5. Initiating asynchronous write operation.</span></div>
<div class="line">      s-&gt;sock-&gt;async_write_some(asio::buffer(s-&gt;buf),</div>
<div class="line">                                std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">      <span class="keyword">auto</span> console = logging::setup();</div>
<div class="line"> </div>
<div class="line">      std::string raw_ip_address = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port_num = 3333;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">try</span> </div>
<div class="line">      {</div>
<div class="line">        asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num);</div>
<div class="line">        asio::io_service ios;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 3. Allocating, opening and connecting a socket.</span></div>
<div class="line">        <span class="keyword">auto</span> sock = std::make_shared&lt;asio::ip::tcp::socket&gt;(ios, ep.protocol());</div>
<div class="line">        sock-&gt;connect(ep);</div>
<div class="line"> </div>
<div class="line">        writeToSocket(sock);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 6.</span></div>
<div class="line">        <span class="comment">// The run() method blocks, as long as, at least one pending asynchronous operation. When the last</span></div>
<div class="line">        <span class="comment">// callback of the last pending asynchronous operation is completed, this method returns.</span></div>
<div class="line">        ios.run();</div>
<div class="line">      } </div>
<div class="line">      <span class="keywordflow">catch</span> (asio::system_error&amp; e) </div>
<div class="line">      {</div>
<div class="line">        console-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, e.code().value(), e.what());</div>
<div class="line">        <span class="keywordflow">return</span> e.code().value();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The write operation <code>async_write_some</code> may not write all of the requested number of bytes. Consider using the <code>async_write</code> function if you need to ensure that the requested amount of data is written before the asynchronous operation completes.</p>
<p>In last boost standards this function is <b>deduced</b>. More information you can see in <a href="https://www.boost.org/doc/libs/1_76_0/doc/html/boost_asio/reference/basic_stream_socket/async_write_some.html">Boost Documentation</a>.</p>
<p><a class="anchor" id="async_write"></a></p><h4>async_write() </h4>
<p>Although the <code>async_write_some()</code> method allows asynchronously writing data to the socket, the solution based on it is somewhat complex and error-prone. Fortunately, Boost.Asio provides a more convenient way to asynchronously write data to a socket using the free function asio::async_write().</p>
<p>Let's consider one of its overloads:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> AsyncWriteStream,</div>
<div class="line">    <span class="keyword">typename</span> ConstBufferSequence,</div>
<div class="line">    <span class="keyword">typename</span> WriteHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_write(</div>
<div class="line">    AsyncWriteStream &amp; s,</div>
<div class="line">    <span class="keyword">const</span> ConstBufferSequence &amp; buffers,</div>
<div class="line">    WriteHandler handler);</div>
</div><!-- fragment --><h4>Algorithm </h4>
<p>The asynchronous write algorithm is the same as when using the function <code>async_write_some</code> except for item 7 of the algorithm. It doesn't exists.</p>
<h4>Code example </h4>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;asio.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>boost;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1.</span></div>
<div class="line"><span class="comment">// Keeps objects we need in a callback to</span></div>
<div class="line"><span class="comment">// identify whether all data has been written</span></div>
<div class="line"><span class="comment">// to the socket and to initiate next async</span></div>
<div class="line"><span class="comment">// writing operatino if needed.</span></div>
<div class="line"><span class="keyword">struct </span>Session </div>
<div class="line">{</div>
<div class="line">      std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock;</div>
<div class="line">      std::string buf;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2.</span></div>
<div class="line"><span class="comment">// Function used as a callback for asynchronous writing operation. Checks if all data from the buffer has been</span></div>
<div class="line"><span class="comment">// written to the socket and initiates new writting operation if needed.</span></div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> asio::error_code&amp; ec, std::size_t bytes_transferred, std::shared_ptr&lt;Session&gt; s) </div>
<div class="line">{</div>
<div class="line">      <span class="keywordflow">if</span> (ec.value() != 0) </div>
<div class="line">      {</div>
<div class="line">        logging::get()-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, ec.value(), ec.message());</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Here we know that all the data has been written to the socket.</span></div>
<div class="line">      logging::get()-&gt;info(<span class="stringliteral">&quot;Bytes read: {}&quot;</span>, bytes_transferred);</div>
<div class="line">      logging::get()-&gt;info(<span class="stringliteral">&quot;Message: {}&quot;</span>, s-&gt;buf);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> writeToSocket(std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock)</div>
<div class="line">{</div>
<div class="line">      std::shared_ptr&lt;Session&gt; s(<span class="keyword">new</span> Session);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 4. Allocating and filling the buffer.</span></div>
<div class="line">      s-&gt;buf = std::string(<span class="stringliteral">&quot;Hello\n&quot;</span>);</div>
<div class="line">      s-&gt;sock = sock;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Step 5. Initiating asynchronous write operation.</span></div>
<div class="line">      asio::async_write(*sock, asio::buffer(s-&gt;buf),</div>
<div class="line">                        std::bind(callback, std::placeholders::_1, std::placeholders::_2, s));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> console = logging::setup();</div>
<div class="line"> </div>
<div class="line">      std::string raw_ip_address = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port_num = 3333;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">try</span> </div>
<div class="line">      {</div>
<div class="line">        asio::ip::tcp::endpoint ep(asio::ip::address::from_string(raw_ip_address), port_num);</div>
<div class="line">        asio::io_service ios;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 3. Allocating, opening and connecting a socket.</span></div>
<div class="line">        std::shared_ptr&lt;asio::ip::tcp::socket&gt; sock(<span class="keyword">new</span> asio::ip::tcp::socket(ios, ep.protocol()));</div>
<div class="line">        sock-&gt;connect(ep);</div>
<div class="line"> </div>
<div class="line">        writeToSocket(sock);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Step 6.</span></div>
<div class="line">        ios.run();</div>
<div class="line">      } </div>
<div class="line">      <span class="keywordflow">catch</span> (asio::system_error&amp; e) </div>
<div class="line">      {</div>
<div class="line">        console-&gt;error(<span class="stringliteral">&quot;Error occurred! Error code = {}. Message: {}&quot;</span>, e.code().value(), e.what());</div>
<div class="line">        <span class="keywordflow">return</span> e.code().value();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="dataIntegrity"></a></p><h2>Data integrity </h2>
<p>If talking about data integrity functions such as <code>async_read</code>, <code>async_write</code> guarantees that all of the requested number of bytes will be read to the stream or written from the stream. This functions will wait all bytes and only after receiving/sending all of them the handler will be called. But if we specify the completion function, reading/writing transfering may be stopped and handler called when the completion function returns 0.</p>
<p><a class="anchor" id="errorHandling"></a></p><h2>@ref "3" "Error and exception handling" </h2>
<p>Boost::asio gives 2 ways of handling errors and exceptions:</p><ul>
<li>using try-cath block</li>
<li>using error codes</li>
</ul>
<p>All the <b>synchronous functions</b> have overloads that either throw in case of error or can return an error code. In case the function throws, it will always throw a <code>boost::system::system_error</code> error.</p>
<p>In case you're using <b>asynchronous functions</b>, they all return an error code, which you can examine in your callback. Asynchronous functions never throw an exception, as it would make no sense to do so.</p>
<p>In your synchronous functions, you can use exceptions or error codes (whatever you wish), but do it consistently. Mixing them up can cause problems and most of the time crashes (when you forget to handle a thrown exception, by mistake). If your code is complex (socket read/write function calls), you should probably prefer exceptions and embody your reads/writes in the try {} catch block of a function.</p>
<p>All Boost.Asio error codes are in namespace <code>boost::asio::error</code>.</p>
<h4>Code example </h4>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// throwing exceptions</span></div>
<div class="line"><span class="keywordflow">try</span> </div>
<div class="line">{</div>
<div class="line">    sock.connect(ep);</div>
<div class="line">} </div>
<div class="line"><span class="keywordflow">catch</span>(boost::system::system_error e) </div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; e.code() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using error codes</span></div>
<div class="line">boost::system::error_code err;</div>
<div class="line">sock.connect(ep, err);</div>
<div class="line"><span class="keywordflow">if</span> ( err) </div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; err &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3>@ref "2" "Delayed processing exceptions"</h3>
<p>Processing exceptions is not always trivial and may take a lot of time. Consider the situation where an exception must be serialized and sent by the network. This may take milliseconds and a few thousand lines of code. After the exception is caught is not always the best time and place to process it.</p>
<p>The Boost.Exception library provides an ability to store and rethrow exceptions. The <code>boost::current_exception()</code> method must be called from inside the catch() block, and it returns an object of the type <code>boost::exception_ptr</code>.</p>
<p>The only way to restore the exception type from <code>boost::exception_ptr</code> is to rethrow it using </p><div class="fragment"><div class="line">::rethrow_exception(exc)</div>
</div><!-- fragment --><p> and then catch it by specifying the exception type.</p>
<p>Usually, exception_ptr is used to pass exceptions between threads. For example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> run_throw(boost::exception_ptr&amp; ptr) </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// A lot of code goes here</span></div>
<div class="line">    } </div>
<div class="line">    <span class="keywordflow">catch</span> (...) </div>
<div class="line">    {</div>
<div class="line">        ptr = boost::current_exception();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ()     </div>
<div class="line">{</div>
<div class="line">     boost::exception_ptr ptr;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Do some work in parallel</span></div>
<div class="line">     boost::thread t(boost::bind(</div>
<div class="line">         &amp;run_throw, </div>
<div class="line">         boost::ref(ptr)</div>
<div class="line">     ));</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Some code goes here</span></div>
<div class="line">     <span class="comment">// â€¦</span></div>
<div class="line">     t.join();</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Checking for exception</span></div>
<div class="line">     <span class="keywordflow">if</span> (ptr) </div>
<div class="line">     {</div>
<div class="line">         <span class="comment">// Exception occured in thread</span></div>
<div class="line">         boost::rethrow_exception(ptr);</div>
<div class="line">     }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="bigFileTransmissions"></a></p><h2>Big file transmissions</h2>
<h3>Algorithm</h3>
<ol type="1">
<li>Create file if not exists.</li>
<li>Open file in reading/writing mode.</li>
<li>Transfer the file data over network / Get data and write it into the file.</li>
<li>Close file.</li>
</ol>
<p>What we can use?</p>
<p><b> 1. Transferring file using <code>async_read_some</code>, <code>async_write_some</code> functions </b></p>
<p>The way how to transfer data using <code>async_read_some</code>, <code>async_write_some</code> was described before in chapters about asynchronous <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#async_read_some">reading</a> and <a class="el" href="md__docs_2_deeping_01intro_01_a_s_i_o.html#async_write_some">writing</a>.</p>
<p>But there may be cases when data size is too big for creating a buffer for it.</p>
<p><b> 2. Transferring composite buffers using <code>async_read</code>, <code>async_write</code> functions </b></p>
<p>A composite buffer is basically a complex buffer that consists of two or more simple buffers (contiguous blocks of memory) distributed over the process' address space. Such buffers become especially handy in two situations.</p>
<ul>
<li>need to store message in a buffer, but message is so huge as program may fail due to the process' address space fragmentation. In this case, allocating multiple smaller buffers, whose sizes when summed would be enough to store the data, and combining them in a single composite buffer is a good solution to the problem.</li>
<li>due to specificity of the design of the application, the message to be sent to the remote application is broken into several parts and stored in different buffers, or if the message to be received from the remote application needs to be broken into several parts, each of which should be stored in a separate buffer for further processing.</li>
</ul>
<h3>Algorithm </h3>
<h4>1. Preparing a composite buffer for gather output operations </h4>
<p>The following is the algorithm and corresponding code sample that describe how to prepare the composite buffer that is to be used with the socket's method that performs output operations such as <code>asio::ip::tcp::socket::send()</code> or a free function such as </p><div class="fragment"><div class="line">::write()</div>
</div><!-- fragment --><p> :</p>
<ol type="1">
<li>Allocate as many memory buffers as needed to perform the task at hand. Note that this step does not involve any functionality or data types from Boost.Asio.</li>
<li>Fill the buffers with data to be output.</li>
<li>Create an instance of a class that satisfies the ConstBufferSequence or MultipleBufferSequence concept's requirements, representing a composite buffer.</li>
<li>Add simple buffers to the composite buffer. Each simple buffer should be represented as an instance of the <div class="fragment"><div class="line">::const_buffer</div>
</div><!-- fragment --> or <code>asio::mutable_buffer</code> classes.</li>
<li>The composite buffer is ready to be used with Boost.Asio output functions.</li>
</ol>
<h5>Code Example </h5>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;boost/asio.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{ </div>
<div class="line">    <span class="comment">// Steps 1 and 2. Create and fill simple buffers. </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* part1 = <span class="stringliteral">&quot;Hello &quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* part2 = <span class="stringliteral">&quot;my &quot;</span>; </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* part3 = <span class="stringliteral">&quot;friend!&quot;</span>; </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3. Create an object representing a composite buffer. </span></div>
<div class="line">    std::vector composite_buffer; </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 4. Add simple buffers to the composite buffer. </span></div>
<div class="line">    composite_buffer.push_back(asio::const_buffer(part1, 6));   </div>
<div class="line">    composite_buffer.push_back(asio::const_buffer(part2, 3)); </div>
<div class="line">    composite_buffer.push_back(asio::const_buffer(part3, 7)); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 5. Now composite_buffer can be used with Boost.Asio </span></div>
<div class="line">    <span class="comment">// output operations as if it was a simple buffer represented </span></div>
<div class="line">    <span class="comment">// by contiguous block of memory. </span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0; </div>
<div class="line">}</div>
</div><!-- fragment --><h4>2. Preparing a composite buffer for an input operation </h4>
<p>The following is the algorithm and corresponding code sample that describe how to prepare the composite buffer that is to be used with the socket's method that performs an input operation such as <code>asio::ip::tcp::socket::receive()</code> or a free function such as </p><div class="fragment"><div class="line">::read()</div>
</div><!-- fragment --><p> :</p>
<ol type="1">
<li>Allocate as many memory buffers as required to perform the task at hand. The sum of the sizes of the buffers must be equal to or greater than the size of the expected message to be received in these buffers. Note that this step does not involve any functionalities or data types from Boost.Asio.</li>
<li>Create an instance of a class that satisfies the MutableBufferSequence concept's requirements that represents a composite buffer.</li>
<li>Add simple buffers to the composite buffer. Each simple buffer should be represented as an instance of the <code>asio::mutable_buffer</code> class.</li>
<li>The composite buffer is ready to be used with Boost.Asio input operations.</li>
</ol>
<h5>Code Example </h5>
<p>Let's imagine a hypothetical situation, where we want to receive 16 bytes long messages from the server. However, we do not have a buffer that can fit the entire message. Instead, we have three buffers: 6, 3, and 7 bytes long. To create a buffer in which we can receive 16 bytes of data, we can join our three small buffers into a composite one. This is how we do it in the following code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;boost/asio.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{ </div>
<div class="line">    <span class="comment">// Step 1. Allocate simple buffers. </span></div>
<div class="line">    <span class="keywordtype">char</span> part1[6]; </div>
<div class="line">    <span class="keywordtype">char</span> part2[3]; </div>
<div class="line">    <span class="keywordtype">char</span> part3[7]; </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2. Create an object representing a composite buffer. </span></div>
<div class="line">    std::vector composite_buffer; </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3. Add simple buffers to the composite buffer object. </span></div>
<div class="line">    composite_buffer.push_back(asio::mutable_buffer(part1, <span class="keyword">sizeof</span>(part1))); </div>
<div class="line">    composite_buffer.push_back(asio::mutable_buffer(part2, <span class="keyword">sizeof</span>(part2))); </div>
<div class="line">    composite_buffer.push_back(asio::mutable_buffer(part3, <span class="keyword">sizeof</span>(part3))); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 4. Now composite_buffer can be used with Boost.Asio </span></div>
<div class="line">    <span class="comment">// input operation as if it was a simple buffer </span></div>
<div class="line">    <span class="comment">// represented by contiguous block of memory. </span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0; </div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="bigProjects"></a></p><h2>Usage in Open Source projects</h2>
<p>There are some libraries such that are based on Boost.Asio.</p>
<ul>
<li><a href="https://github.com/splunk/pion">libpion</a> - C++ framework for building lightweight HTTP interfaces</li>
<li><a href="https://sourceforge.net/projects/cpp-netlib/">cpp-netlib</a> - a collection of network-related routines/implementations geared towards providing a robust cross-platform networking library. <br  />
 Cpp-netlib offers the following implementations:<ul>
<li>Common Message Type - a generic message type which can be used to encapsulate and store message-related information, used by all network implementations as the primary means of data exchange.</li>
<li>Network protocol message parsers - a collection of parsers which generate message objects from strings.</li>
<li>Adapters and Wrappers - a collection of Adapters and wrappers aimed towards making the message type STL friendly.</li>
<li>Network protocol client and server implementations - a collection of network protocol implementations that include embeddable client and server types.</li>
</ul>
</li>
<li><a href="https://www.rasterbar.com/products/libtorrent/">libtorrent</a> - a feature complete C++ bittorrent implementation focusing on efficiency and scalability. It runs on embedded devices as well as desktops. It comes with a simple bittorrent client demonstrating the use of the library.</li>
</ul>
<p><a class="anchor" id="toRead"></a></p><h2>To read</h2>
<p><a class="anchor" id="1"></a>1. Dmytro Radchuk. Boost.Asio C++ Network Programming Cookbook. <a href="https://github.com/ct-clmsn/asio-network-programming-cookbook/tree/master/src/ch02">repo</a><br  />
 <a class="anchor" id="2"></a>2. Antony Polukhin. Boost C++ Application Development Cookbook <a href="https://github.com/apolukhin/Boost-Cookbook/tree/second_edition/Chapter06">(Chapter 6)</a>.<br  />
 <a class="anchor" id="3"></a>3. John Torjo. Boost.Asio C++ Network Programming.<br  />
 <a class="anchor" id="4"></a>4. <a href="https://www.boost.org">Boost Documentation</a><br  />
</p><ol type="1">
<li><a href="https://docs.google.com/presentation/d/16wfo8neJ2Y-g9KLuwEDjb6MxgsnPrpVa9FnWXQKSYAs/edit?usp=sharing">Presentation</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
